\section{Hello, Haskell}

Welcome to your first step in learning Haskell. 

Before you begin with the main course of this book, you will need to install the necessary tools in order to complete the exercises as you work through the book. At this time, we recommend installing Stack, which will install GHC Haskell, the interactive environment called GHCi, and a project build tool and dependency manager all at once. 

You can find the installation instructions online at \url{http://docs.haskellstack.org/en/stable/README/}, and there is also great documentation that can help you get started using Stack. You can also find installation instructions at \url{https://github.com/bitemyapp/learnhaskell}, and there you will also find advice on learning Haskell and links to more exercises that may supplement what you're doing with this book.

The rest of this chapter will assume that you have completed the installation and are ready to begin working. In this chapter, you will

\begin{itemize}
\item use Haskell code in the interactive environment and also from source files;
\item understand the building blocks of Haskell: expressions and functions;
\item learn some features of Haskell syntax and conventions of good Haskell style;
\item modify simple functions.
\end{itemize}

\section{Interacting with Haskell code}

Haskell offers two primary ways of working with code. The first is inputting it directly into the interactive environment known as GHCi, or the REPL. The second is typing it into a text editor, saving, and then loading that source file into GHCi. This section offers an introduction to each method.

\subsection{Using the REPL}

REPL is an acronym short for \emph{read-eval-print loop}. REPLs are interactive programming environments where you can input code, have it evaluated, and see the result. They originated with Lisp but are now common to modern programming languages including Haskell.
\index{REPL ! Read-eval-print loop}
\index{REPL}
\index{Lisp}

Assuming you've completed your installation, you should be able to open your terminal or command prompt, type \texttt{ghci} or \texttt{stack ghci}, hit enter, and see something like the following:
\index{GHCi}

\begin{verbatim}
GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
Prelude>
\end{verbatim}

If you used \texttt{stack ghci}\footnote{At this point in the book, you don't need to use \texttt{stack ghci}, but in later chapters when we're importing a lot of modules and building projects, it will be much more convenient to use it.} there was probably a lot more startup text, and the prompt might be something other than \texttt{Prelude}. That's all fine. You may also have a different version of GHC. As long as your GHC version is between 7.8 and 8.0, it should be compatible with everything in this book.

Now try entering some simple arithmetic at your prompt:

\begin{verbatim}
Prelude> 2 + 2
4
Prelude> 7 < 9
True
Prelude> 10 ^ 2
100
\end{verbatim}

If you can enter simple equations at the prompt and get the expected results, congratulations --- you are now a functional programmer! More to the point, your REPL is working well and you are ready to proceed.

To exit GHCi, use the command \texttt{:quit} or \texttt{:q}.

\paragraph{What is Prelude?} Prelude is a library of standard functions. Opening GHCi or Stack GHCi automatically loads those functions so they can be used without needing to do anything special. You can turn Prelude off, as we will show you much later, and there are alternative Preludes, though we won't use them in the book. Prelude is contained in Haskell's \texttt{base} package, which can be found at \url{https://www.stackage.org/package/base}. You'll see us mention sometimes that something or other is ``in \texttt{base}'' which means it's contained in that vast foundational package.

\subsection{GHCi commands}

Throughout the book, we'll be using GHCi commands, such as \texttt{:quit} and \texttt{:info} in the REPL. Special commands that only GHCi understands begin with the \texttt{:} character. \texttt{:quit} is \emph{not} Haskell code; it's just a GHCi feature. We will see more of these commands throughout the book.

We will present them in the text spelled out, but they can generally be abbreviated to just the colon and the first letter. That is, \texttt{:quit} becomes \texttt{:q}, \texttt{:info} becomes \texttt{:i} and so forth. It's good to type the word out the first few times you use it, to help you remember what the abbreviation stands for, but after a few mentions, we will start abbreviating them. 

\subsection{Working from source files}

As nice as REPLs are, usually you want to store code in a file so you can build it incrementally. Almost all nontrivial programming you do will involve editing libraries or applications made of nested directories containing files with Haskell code in them. The basic process is to have the code and imports (more on that later) in a file, load it into the REPL, and interact with it there as you're building, modifying, and testing it.

You'll need a file named \texttt{test.hs}. The \texttt{.hs} file extension denotes a Haskell source code file. Depending on your setup and the workflow you're comfortable with, you can make a file by that name and then open it in your text editor or you can open your text editor, open a new file, and then save the file with that file name.

Then enter the following code into the file and save it:
\index{source code ! file}
\index{denotation ! denotes}

\begin{code}
sayHello :: String -> IO ()
sayHello x = putStrLn ("Hello, " ++ x ++ "!")
\end{code}

Here, \texttt{::} is a way to write down a type signature. You can think of it as saying, ``has the type.'' So, \texttt{sayHello} has the type \texttt{String -> IO ()}. These first chapters are focused on syntax, so if you don't understand what types or type signatures are, that's OK --- we will explain them soon. For now, keep going.

Then in the same directory where you've stored your \texttt{test.hs} file, open your \texttt{ghci} REPL and do the following:

\begin{verbatim}
Prelude> :load test.hs
Prelude> sayHello "Haskell"
Hello, Haskell!
Prelude>
\end{verbatim}

After using \texttt{:load} to load your \texttt{test.hs}, the \texttt{sayHello} function is visible in the REPL and you can pass it a string argument, such as ``Haskell'' (note the quotation marks), and see the output.

\section{Understanding expressions}

Everything in Haskell is an expression or declaration. Expressions may be values, combinations of values, and/or functions applied to values. Expressions evaluate to a result. In the case of a literal value, the evaluation is trivial as it only evaluates to itself. In the case of an arithmetic equation, the evaluation process is the process of computing the operator and its arguments, as you might expect. But, even though not all of your programs will be about doing arithmetic, all of Haskell's expressions work in a similar way, evaluating to a result in a predictable, transparent manner. Expressions are the building blocks of our programs, and programs themselves are one big expression made of smaller expressions. 

We'll cover declarations more later, but it suffices to say for now that they are top-level bindings which allows us to name expressions. We can then use those names to refer to them multiple times without copying and pasting the expressions.
\index{value}
\index{expression}
\index{function}
\index{function ! application}
\index{programming language}
\index{declaration}

The following are all expressions:

\begin{code}
1
1 + 1
"Icarus"
\end{code}

Each can be examined in the GHCi REPL by entering the code at the prompt, then hitting `enter' to see the result of evaluating the expression. The numeric value 1, for example, has no further reduction step, so it stands for itself. 
\index{number}
\index{reduction}

If you haven't already, open up your terminal and get your REPL going to start following along with the code examples.

When we enter this into GHCi:
\index{GHCi}
\index{REPL}
\index{prompt}
\index{evaluation}

\begin{verbatim}
Prelude> 1
1
\end{verbatim}

We see 1 printed because it cannot be reduced any further.

In the next example, GHCi reduces the expression \texttt{1 + 2} to $3$, then prints the number 3. The reduction terminates with the value 3 because there are no more terms to evaluate:

\index{terminate}
\index{print}

\begin{verbatim}
Prelude> 1 + 2
3
\end{verbatim}

Expressions can be nested in numbers limited only by our willingness to take the time to write them down, much like in arithmetic:

\begin{verbatim}
Prelude> (1 + 2) * 3
9
Prelude> ((1 + 2) * 3) + 100
109
\end{verbatim}

You can keep expanding on this, nesting as many expressions as you'd like and evaluating them. But, we don't have to limit ourselves to expressions such as these.

\paragraph{Normal form}We say that expressions are in \emph{normal form} when there are no more evaluation steps that can be taken, or, put differently, when they've reached an irreducible form. The normal form of \texttt{1 + 1} is $2$. Why? Because the expression \texttt{1 + 1} can be evaluated or reduced by applying the addition operator to the two arguments. In other words, \texttt{1 + 1} is a reducible expression, while $2$ is an expression but is no longer reducible --- it can't evaluate into anything other than itself. Reducible expressions are also called \emph{redexes}. While we will generally refer to this process as evaluation or reduction, you may also hear it called ``normalizing'' or ``executing'' an expression, though these are somewhat imprecise.
\index{normal form}
\index{redex ! reducible expressions}
\index{nesting}

\section{Functions}

Expressions are the most basic unit of a Haskell program, and functions are a specific type of expression. Functions in Haskell are related to functions in mathematics, which is to say they map an input or set of inputs to an output. A function is an expression that is applied to an argument and always returns a result. Because they are built purely of expressions, they will always evaluate to the same result when given the same values.

As in the lambda calculus, all functions in Haskell take one argument and return one result. The way to think of this is that, in Haskell, when it seems we are passing multiple arguments to a function, we are actually applying a series of nested functions, each to one argument. This is called \emph{currying}, and it will be addressed in greater detail later.

You may have noticed that the expressions we've looked at so far use literal values with no variables or abstractions. Functions allow us to abstract the parts of code we'd want to reuse for different literal values. Instead of nesting addition expressions, for example, we could write a function that would add the value we wanted wherever we called that function.

For example, say you had a bunch of simple expressions you needed to multiply by 3. You could keep entering them as individual expressions like this:

\begin{verbatim}
Prelude> (1 + 2) * 3
9
Prelude> (4 + 5) * 3
27
Prelude> (10 + 5) * 3
45
\end{verbatim}

But you don't want to do that. Functions are how we factor out the pattern into something we can reuse with different inputs. You do that by naming the function and introducing an independent variable as the argument to the function. Functions can also appear in the expressions that form the bodies of other functions or be used as arguments to functions, just as any other value can be.

In this case, we have a series of expressions that we want to multiply by 3. Let's think in terms of a function: what part is common to all the expressions? What part varies? We know we have to give functions a name and apply them to an argument, so what could we call this function and what sort of argument might we apply it to?

The common pattern is the \texttt{* 3} bit. The part that varies is the addition expression before it, so we will make that a variable. We will name our function and apply it to the variable. When we input a value for the variable, our function will evaluate that, multiply it by 3, and return a result. In the next section, we will formalize this into a proper Haskell function.

\subsection{Defining functions}

Function definitions all share a few things in common. First, they start with the name of the function. This is followed by the formal \emph{parameters}\footnotemark{} of the function, separated only by white space. Next there is an equal sign, which expresses equality of the terms. Finally there is an expression that is the body of the function and can be evaluated to return a value.

%% CHRIS check that -- changed wording due to Wadler's comment

\footnotetext{ In practice, the terms `argument' and `parameter' are often used interchangeably, but there is a difference. `Argument' properly refers to the value(s) that are passed to the function's parameters when the function is applied, not to the variables that represent them in the function definition (or those in the type signature). See the definitions at the end of the chapter for more information. }

Defining functions in a normal Haskell source code file and in GHCi are a little different. To introduce definitions of values or functions in GHCi you must use \texttt{let}, which looks like this:
\index{GHCi}
\index{let}
\index{declaration}
\index{source code}
\index{file}
\index{value}
\index{function}

\begin{verbatim}
Prelude> let triple x = x * 3
\end{verbatim}

In a source file we would enter it like this:

\begin{code}
triple x = x * 3
\end{code}

Let's examine each part of that:

\begin{code}
  triple x   =   x * 3
-- [1]  [2] [3]  [ 4 ]
\end{code}

\begin{enumerate}

\item This is the name of the function we are defining; it is a function \emph{declaration}. Note that it begins with a lowercase letter.

\item This is the parameter of the function. The arguments to our function correspond to the ``head'' of a lambda and bind variables that appear in the body expression.
%% CHRIS wording check

\item The $=$ is used to define (or \emph{declare}) values and functions. Reminder: this is \emph{not} how we test for  equality between two values in Haskell.

\item This is the body of the function, an expression that could be evaluated if the function is applied to a value. If \texttt{triple} is applied, the argument it's applied to will be the value to which the $x$ is bound. Here the expression \texttt{x * 3} constitutes the body of the function. So, if you have an expression like \texttt{triple 6}, $x$ is bound to 6. Since you've applied the function, you can also replace the fully applied function with its body and bound arguments.
\end{enumerate}
\index{declaration}
\index{function ! arguments}

\paragraph{Capitalization matters!} Function names start with lowercase letters. Sometimes for clarity in function names, you may want camelCase style, and that is good style provided the first letter remains lowercase.

Variables must also begin with lowercase letters.

\paragraph{Playing with the triple function}

First, try entering the \texttt{triple} function directly into the REPL using \texttt{let}. Now call the function by name and introduce a numeric value for the $x$ argument:

\index{number}

\begin{verbatim}
Prelude> triple 2
6
\end{verbatim}

Next, enter the second version (the one without \texttt{let}) into a source file and save the file. Load it into GHCi, using the \texttt{:load} or \texttt{:l} command. Once it's loaded, you can call the function at the prompt using the function name, \texttt{triple}, followed by a numeric value, just as you did in the REPL example above. Try using different values for $x$ --- integer values or other arithmetic expressions. Then try changing the function itself in the source file and reloading it to see what changes. 
\index{function ! call}

\section{Evaluation}

\section{Evaluation}

When we talk about evaluating an expression, we're talking about reducing the terms until the expression reaches its simplest form. Once a term has reached its simplest form, we say that it is irreducible or finished evaluating. Usually, we call this a value. Haskell uses a non-strict evaluation (sometimes called ``lazy evaluation'') strategy which defers evaluation of terms until they're forced by other terms referring to them. We will return to this concept several times throughout the book as it takes time to fully understand.
\index{expression}
\index{non-strict}
\index{reduction}
\index{term}

Values are irreducible, but applications of functions to arguments are reducible. Reducing an expression means evaluating the terms until you're left with a value. As in the lambda calculus, application is evaluation: applying a function to an argument allows evaluation or reduction.

Values are expressions, but cannot be reduced further. Values are a terminal point of reduction:

\begin{code}
1
"Icarus"
\end{code}

The following expressions can be reduced (evaluated, if you will) to a value:

\begin{code}
1 + 1
2 * 3 + 1
\end{code}

Each can be evaluated in the REPL, which reduces the expressions and then prints what it reduced to.

Let's get back to our \texttt{triple} function. Calling the function by name and applying it to an argument makes it a reducible expression. In a pure functional language like Haskell, we can replace applications of functions with their definitions and get the same result, just like in math. As a result when we see:
\index{redex}
\index{function ! application}
\index{function ! mathematical}

\begin{code}
triple 2
\end{code}

We can know that, since triple is defined as \texttt{x = x * 3}, the expression is equivalent to:
\index{expression}

\begin{code}
triple 2
--[triple x = x * 3; x:= 2]
2 * 3
6
\end{code}

We've applied \texttt{triple} to the value 2 and then reduce the expression to the final result 6. Our expression \texttt{triple 2} is in canonical or \emph{normal form} when it reaches the number 6 because the value 6 has no remaining reducible expressions. 
\index{redex}

Haskell doesn't evaluate everything to canonical or normal form by default. Instead, it only evaluates to weak head normal form (WHNF) by default. We'll get into the details of what that means somewhat later in the book. For now, we want to emphasize that Haskell's nonstrict evaluation means not everything will get reduced to its irreducible form immediately, so this:
%% CHRIS as we talked about with Sterling's feedback, do you want an example here? i can't think of one that is something we've covered so far that won't just automatically evalute. nesting addition inside Left as Sterling did. you suggested this:
% Come up with something nested so they don't mistake it for strict evaluation.
%% (\f -> (1, 2 + f)) 2
%% Reduces to in WHNF:
%% (1, 2 + 2)
%% Comment that we don't evaluate 2 + 2 until we need to.
%% but i think it'll force the 2 + 2 because + is strict, is there something we could do at this point that wouldn't be? seems like maybe we should just point out that they don't automatically evaluate everything due to nonstrictness, mention WHNF and say we'll explain it later when we're able to give more clear examples?
%% CHRIS end of that comment

You may notice that after loading code from a source file, the GHCi prompt is no longer \texttt{Prelude>}. To return to the \texttt{Prelude>} prompt, use the command \texttt{:m}, which is short for \texttt{:module}. This will unload the file from GHCi, so the code in that file will no longer be in scope in your REPL.
\index{GHCi ! :module}

\subsection{Exercises: Comprehension Check}

\begin{enumerate}
\item Given the following lines of code as they might appear in a source file, how would you change them to use them directly in the REPL?

\begin{code}
half x = x / 2

square x = x * x
\end{code}

\item Write one function that can accept one argument and work for all the following expressions. Be sure to name the function.

\begin{code}
3.14 * (5 * 5)
3.14 * (10 * 10)
3.14 * (2 * 2)
3.14 * (4 * 4)
\end{code}

\item There is a value in Prelude called \texttt{pi}. Rewrite your function to use \texttt{pi} instead of 3.14.

\end{enumerate}

\section{Infix operators}

Functions in Haskell default to prefix syntax, meaning that the function being applied is at the beginning of the expression rather than the middle. We saw that with our \texttt{triple} function, and we see it with standard functions such as the identity, or \texttt{id}, function. This function just returns whatever value it is given as an argument:
\index{prefix}
\index{function ! prefix}

\begin{verbatim}
Prelude> id 1
1
\end{verbatim}

While this is the default syntax for functions, not all functions are prefix. There are a group of operators, such as the arithmetic operators we've been using, that are indeed functions (they apply to arguments to produce an output) but appear by default in an infix position.

Operators are functions which can be used in infix style. All operators are functions; not all functions are operators. While \texttt{triple} and \texttt{id} are prefix functions (\emph{not} operators), the \texttt{+} function is an infix operator:
\index{infix}
\index{operator ! function}
\index{function ! operator}

\begin{verbatim}
Prelude> 1 + 1
2
\end{verbatim}

Now we'll try a few other mathematical operators:

\begin{verbatim}
Prelude> 100 + 100
200
Prelude> 768395 * 21356345
16410108716275
Prelude> 123123 / 123
1001.0
Prelude> 476 - 36
440
Prelude> 10 / 4
2.5
\end{verbatim}

You can sometimes use functions infix style, with a small change in syntax:

\begin{verbatim}
Prelude> 10 `div` 4
2
Prelude> div 10 4
2
\end{verbatim}

And you can use infix operators in prefix fashion by wrapping them in parentheses:

\begin{verbatim}
Prelude> (+) 100 100
200
Prelude> (*) 768395 21356345
16410108716275
Prelude> (/) 123123 123
1001.0
\end{verbatim}

If the function name is alphanumeric, it is prefix by default, and not all prefix functions can be made infix. If the name is a symbol, it is infix by default but can be made prefix by wrapping it in parentheses.\footnote{For people who like nitpicky details: you cannot make a prefix function into an infix function using backticks, then wrap that in parentheses and make it into a prefix function. We're not clear why you'd want to do that anyway. Cut it out.}
%% CHRIS OK?

\subsection{Associativity and precedence}

As you may remember from your math classes, there's a default associativity and precedence to the infix operators \texttt{(*)}, \texttt{(+)}, \texttt{(-)}, and \texttt{(/)}.
\index{associativity}
\index{precedence}

We can ask GHCi for information such as associativity and precedence of operators and functions by using the \texttt{:info} command. When you ask GHCi for the \texttt{:info} about an operator or function, it provides the type information It also tells you whether it's an infix operator, and, if it is, its associativity and precedence. Let's talk about that associativity and precedence briefly. We will elide the type information and so forth for now.

Here's what the code in Prelude says for \texttt{(*)}, \texttt{(+)}, and \texttt{(-)} at time of writing:
\index{GHCi ! :info}
\index{infix ! precedence}
\index{operator}
\index{infix ! associativity}

\begin{code}
:info (*)
infixl  7   *
-- [1] [2] [3]

:info (+) (-)
infixl 6 +

infixl 6 -
\end{code}

\begin{enumerate}
\item \texttt{infixl} means it's an infix operator, left associative.
\item 7 is the precedence: higher is applied first, on a scale of 0-9.
\item Infix function name: in this case, multiplication.
\end{enumerate}
\index{infix ! infixl}

The information about addition and subtraction tell us they are both left-associative, infix operators with the same precedence (6).

Let's play with parentheses and see what it means that these associate to the left. Continue to follow along with the code via the REPL:
\index{parentheses}
\index{REPL}

\begin{code}
-- this
2 * 3 * 4

-- is evaluated as if it was
(2 * 3) * 4
-- Because of left-associativity from infixl
\end{code}

Here's an example of a right-associative infix operator:
\index{infix ! infixr}

\begin{verbatim}
Prelude> :info (^)
infixr  8   ^
-- [1] [2] [3]
\end{verbatim}

\begin{enumerate}
\item \texttt{infixr} means infix operator, right associative.
\item 8 is the precedence. Higher precedence, indicated by higher numbers, is applied first, so this is higher precedence than multiplication (7), addition, or subtraction (both 6).
\item Infix function name: in this case, exponentiation.
\end{enumerate}

It was hard to tell with multiplication why associativity mattered, because multiplication is associative. So shifting the parentheses around never changes the result. Exponentiation, however, is not associative and thus makes a prime candidate for demonstrating left vs. right associativity.
\index{associativity}
\index{exponentiation}

\begin{verbatim}
Prelude> 2 ^ 3 ^ 4
2417851639229258349412352
Prelude> 2 ^ (3 ^ 4)
2417851639229258349412352
Prelude> (2 ^ 3) ^ 4
4096
\end{verbatim}

As you can see, adding parentheses starting from the right-hand side of the expression when the operator is right-associative doesn't change anything. However, if we parenthesize from the \emph{left}, we get a different result when the expression is evaluated.
\index{parentheses}

Your intuitions about precedence, associativity, and parenthesization from math classes will generally hold in Haskell:

\begin{code}
2 + 3 * 4

(2 + 3) * 4
\end{code}

What's the difference between these two? Why are they different?

\subsection{Exercises: Parentheses and Association}

Below are some pairs of functions that are alike except for parenthesization. Read them carefully and decide if the parentheses change the results of the function. Check your work in GHCi.

\begin{enumerate}

\item
\begin{enumerate}
\item \texttt{8 + 7 * 9}
\item \texttt{(8 + 7) * 9}
\end{enumerate}

\item
\begin{enumerate}
\item \texttt{perimeter x y = (x * 2) + (y * 2)}
\item \texttt{perimeter x y = x * 2 + y * 2}
\end{enumerate}

\item
\begin{enumerate}
\item \texttt{f x = x / 2 + 9}
\item \texttt{f x = x / (2 + 9)}
\end{enumerate}

\end{enumerate}

\section{Declaring values}

The order of declarations in a source code file doesn't matter because GHCi loads the entire file at once, so it knows all the values that have been defined. On the other hand, when you enter them one by one into the REPL, the order does matter.

For example, we can declare a series of expressions in the REPL like this:

\begin{verbatim}
Prelude> let y = 10
Prelude> let x = 10 * 5 + y
Prelude> let myResult = x * 5
\end{verbatim}

As we saw above with the \texttt{triple} function, we have to use \texttt{let} to declare something in the REPL.

We can now type the names of the values and hit enter to see their values:

\begin{verbatim}
Prelude> x
60
Prelude> y
10
Prelude> myResult
300
\end{verbatim}

To declare the same values in a file, such as \texttt{learn.hs}, we write the following:
\index{file}

\begin{code}
-- learn.hs

module Learn where
-- First, we declare the name of our module so
-- it can be imported by name in a project.
-- We won't be doing a project of this size
-- for a while yet.

x = 10 * 5 + y

myResult = x * 5

y = 10
\end{code}

Remember module names are capitalized, unlike variable names. Also, in this variable name, we've used camelCase: the first letter is still lowercase, but we use an uppercase to delineate a word boundary for readability.
\index{module}

\subsection{Troubleshooting}

It is easy to make mistakes in the process of typing \texttt{learn.hs} into your editor. We'll look at a few common mistakes in this section. One thing to keep in mind is that indentation of Haskell code is significant and can change the meaning of the code. Incorrect indentation of code can also break your code. Reminder: use spaces, \emph{not} tabs, to indent your source code.
\index{indentation}

In general, whitespace is significant in Haskell. Efficient use of whitespace makes the syntax more concise. This can take some getting used to if you've been working in another programming language. Whitespace is often the only mark of a function call, unless parentheses are necessary due to conflicting precedence. Trailing whitespace, that is, extraneous whitespace at the end of lines of code, is considered bad style.
\index{whitespace}
\index{syntax}
\index{style}

In source code files, indentation often replaces syntactic markers like curly brackets, semicolons, and parentheses. The basic rule is that code that is part of an expression should be indented under the beginning of that expression, even when the beginning of the expression is not at the leftmost margin. Furthermore, parts of the expression that are grouped should be indented to the same level. For example, in a block of code introduced by \texttt{let} or \texttt{do}, you might see something like this:
\index{let}
\index{do}

\begin{code}
let
  x = 3
  y = 4

-- or

let x = 3
    y = 4

-- Note that this code won't work directly in a
-- source file without embedding in a
-- top-level declaration
\end{code}

Notice that the two definitions that are part of the expression line up in either case. It is incorrect to write:

\begin{code}
let x = 3
 y = 4

-- or

let
 x = 3
  y = 4
\end{code}

If you have an expression that has multiple parts, your indentation will follow a pattern like this:
\index{expression}
\index{indentation}

\begin{code}
foo x =
    let y = x * 2
        z = x ^ 2
    in 2 * y * z
\end{code}

Notice that the definitions of $y$ and $z$ line up, and the definitions of \texttt{let} and \texttt{in} are also aligned. As you work through the book, try to pay careful attention to the indentation patterns as we have them printed. There are many cases where improper indentation will actually cause code not to work. Indentation can easily go wrong in a copy-and-paste job as well.

Also, when you write Haskell code, we reiterate here that you want to use spaces and \emph{not} tabs for indentation. Using spaces will save you a nontrivial amount of grief. Most text editors can be configured to use only spaces for indentation, so you may want to investigate how to do that for yours.

If you make a mistake like breaking up the declaration of $x$ such that the rest of the expression began at the beginning of the next line:
\index{declaration}

\begin{code}
module Learn where
-- First declare the name of our module so it
-- can be imported by name in a project.
-- We won't do this for a while yet.

x = 10
* 5 + y

myResult = x * 5

y = 10
\end{code}

You might see an error like:

\begin{verbatim}
Prelude> :l code/learn.hs
[1 of 1] Compiling Learn

code/learn.hs:10:1: parse error on input ‘*’
Failed, modules loaded: none.
\end{verbatim}

Note that the first line of the error message tells you where the error occurred: \texttt{code/learn.hs:10:1} indicates that the mistake is in line 10, column 1, of the named file. That can make it easier to find the problem that needs to be fixed. Please note that the exact line and column numbers in your own error messages might be different from ours, depending on how you've entered the code into the file.

The way to fix this is to either put it all on one line, like this:

\begin{code}
x = 10 * 5 + y
\end{code}

or to make certain when you break up lines of code that the second line begins at least one space from the beginning of that line (either of the following should work):

\begin{code}
x = 10
 * 5 + y

-- or

x = 10
    * 5 + y
\end{code}

The second one looks a little better. Generally, you should reserve breaking up of lines for when you have code exceeding 100 columns in width.

Another possible error is not starting a declaration at the beginning (left) column of the line:

\begin{code}
-- learn.hs

module Learn where

 x = 10 * 5 + y

myResult = x * 5

y = 10
\end{code}

See that space before $x$? That will cause an error like:

\begin{verbatim}
Prelude> :l code/learn.hs
[1 of 1] Compiling Learn

code/learn.hs:11:1: parse error on input ‘myResult’
Failed, modules loaded: none.
\end{verbatim}

This may confuse you, as \texttt{myResult} is not where you need to modify your code. The error is only an extraneous space, but all declarations in the module must start at the same column. The column that all declarations within a module must start in is determined by the first declaration in the module. In this case, the error message gives a location that is different from where you should fix the problem because all the compiler knows is that the declaration of $x$ made a single space the appropriate indentation for all declarations within that module, and the declaration of \texttt{myResult} began a column too early.

It is possible to fix this error by indenting the \texttt{myResult} and $y$ declarations to the same level as the indented $x$ declaration:

\begin{code}
-- learn.hs

module Learn where

 x = 10 * 5 + y

 myResult = x * 5

 y = 10
\end{code}

However, this is considered bad style and is not standard Haskell practice. There is almost never a good reason to indent all your declarations in this way, but noting this gives us some idea of how the compiler is reading the code. It is better, when confronted with an error message like this, to make sure that your first declaration is at the leftmost margin and proceed from there.

Another possible mistake is that you might've missed the second \texttt{-} in the \texttt{--} used to comment out source lines of code.

So this code:

\begin{code}
- learn.hs

module Learn where
-- First declare the name of our module so it
-- can be imported by name in a project.
-- We won't do this for a while yet.

x = 10 * 5 + y

myResult = x * 5

y = 10
\end{code}

will cause this error:

\begin{verbatim}
code/learn.hs:7:1: parse error on input ‘module’
Failed, modules loaded: none.
\end{verbatim}

Note again that it says the parse error occurred at the beginning of the module declaration, but the issue is actually that \texttt{- learn.hs} had only one \texttt{-} when it needed two to form a syntactically correct Haskell comment.

Now we can see how to work with code that is saved in a source file from GHCi without manually copying and pasting the definitions into our REPL. Assuming we open our REPL in the same directory as we have \texttt{learn.hs} saved, we can do the following:

\begin{verbatim}
Prelude> :load learn.hs
[1 of 1] Compiling Learn
Ok, modules loaded: Learn.
Prelude> x
60
Prelude> y
10
Prelude> myResult
300
\end{verbatim}

\subsection{Exercises: Heal the Sick}

The following code samples are broken and won't compile. The first two are as you might enter into the REPL; the third is from a source file. Find the mistakes and fix them so that they will.

\begin{enumerate}
\item \texttt{let area x = 3. 14 * (x * x)}
\item \texttt{let double x = b * 2}
\item
\begin{code}
x = 7
 y = 10
f = x + y
\end{code}
\end{enumerate}

\section{Arithmetic functions in Haskell}

This section will explore some basic arithmetic using some common operators and functions for arithmetic. We'll focus on the following subset of them:
\index{arithmetic}
\index{infix}
\index{operator}

\begin{center}

    \begin{tabular}{ | l | l | l |}
    \hline

    Operator & Name & Purpose/application
    \\ \hline

    +  & plus & addition
    \\ \hline

    -  & minus & subtraction
    \\ \hline

    *  & asterisk & multiplication
    \\ \hline

    /  & slash & fractional division
    \\ \hline

    div & divide & integral division, round down
    \\ \hline

    mod & modulo & similar to `rem', but after modular division
    \\ \hline

    quot & quotient & integral division, round towards zero
    \\ \hline

    rem & remainder & remainder after division
    \\ \hline

    \end{tabular}
\end{center}
%% JULIE fix mod. fix mod? no FUCK MOD.

At the risk of stating the obvious, ``integral'' division refers to division of integers. Because it's integral and not fractional, it takes integers as arguments and returns integers as results. That's why the results are rounded.
\index{division}
\index{remainder}
\index{integral}
\index{type}

Here's an example of each in the REPL:

\begin{verbatim}
Prelude> 1 + 1
2
Prelude> 1 - 1
0
Prelude> 1 * 1
1
Prelude> 1 / 1
1.0
Prelude> div 1 1
1
Prelude> mod 1 1
0
Prelude> quot 1 1
1
Prelude> rem 1 1
0
\end{verbatim}

You will usually want \texttt{div} for integral division unless you know what you're doing, due to the way \texttt{div} and \texttt{quot} round:

\begin{verbatim}
-- rounds down
Prelude> div 20 (-6)
-4

-- rounds toward zero
Prelude> quot 20 (-6)
-3
\end{verbatim}

Also, \texttt{rem} and \texttt{mod} have slightly different use cases; we'll look at \texttt{mod} in a little more detail down below. We will cover \texttt{(/)} in more detail in a later chapter, as that will require some explanation of types and typeclasses.

\subsection{Laws for quotients and remainders}

Programming often makes use of more division and remainder functions than standard arithmetic does, and it's helpful to be familiar with the laws about quot/rem and div/mod.\footnotemark{}We'll take a look at those here.
\index{law}

\begin{verbatim}
(quot x y)*y + (rem x y) == x

(div x y)*y + (mod x y) == x
\end{verbatim}

\footnotetext { From Lennart Augustsson's blog \url{http://augustss.blogspot.com/} or Stack Overflow answer at \url{http://stackoverflow.com/a/8111203} }

We won't walk through a proof exercise, but we can demonstrate these laws a bit:

\begin{verbatim}
(quot x y)*y + (rem x y)

Given x is 10 and y is (-4)

(quot 10 (-4))*(-4) + (rem 10 (-4))

quot 10 (-4) == (-2)  and  rem 10 (-4) == 2

(-2)*(-4) + (2) == 10

10 == x == yeppers.
\end{verbatim}

It's not worth getting overly invested in the meaning of ``yeppers'' there; it just means we got to the result we wanted. 

Now for \texttt{div} and \texttt{mod}:

\begin{verbatim}
(div x y)*y + (mod x y)

Given x is 10 and y is (-4)

(div 10 (-4))*(-4) + (mod 10 (-4))

div 10 (-4) == (-3)  and  mod 10 (-4) == -2

(-3)*(-4) + (-2) == 10

10 == x == yeppers.
\end{verbatim}

Our result indicates all is well in the world of integral division.

\subsection{Using `mod`}

This section is not a full discussion of modular arithmetic, but we want to give more direction in how to use \texttt{mod} in general, for those who may be unfamiliar with it, and how it works in Haskell specifically.

We've already mentioned that \texttt{mod} gives the remainder of a modular division. If you're not already familiar with modular division, you may not understand the useful difference between \texttt{mod} and \texttt{rem}.

Modular arithmetic is a system of arithmetic for integers where numbers ``wrap around'' upon reaching a certain value, called the \emph{modulus}. It is often explained in terms of a clock. 

When we count time by a 12-hour clock, we have to wrap the counting around the 12. For example, if the time is now 8:00 and you want to know what time it will be 8 hours from now, you don't simply add 8 + 8 and get a result of 16 o'clock.\footnote{Obviously, with a 24-hour clock, such a time is possible; however, if we were starting from 8:00 p.m. and trying to find the time 8 hours later, the answer would not be 16:00 a.m. A 24-hour clock has a different modulus than a 12-hour clock.}

Instead, you wrap the count around every 12 hours. So, adding 8 hours to 8:00 means that we add 4 hours to get to the 12, and at the 12 we start over again as if it's 0 and add the remaining 4 hours of our 8, for an answer of 4:00. That is, 8 hours after 8:00 is 4:00.

This is arithmetic \emph{modulo} 12. In our 12-hour clock, 12 is equivalent to both itself and to 0, so the time at 12:00 is also, in some sense 0:00. Arithmetic modulo 12 means that 12 is both 12 and 0. 

Often, this will give you the same answer that \texttt{rem} does:

\begin{verbatim}
Prelude> mod 15 12
3
Prelude> rem 15 12
3

Prelude> mod 21 12
9
Prelude> rem 21 12
9

Prelude> mod 3 12
3
Prelude> rem 3 12
3
\end{verbatim}

If you're wondering what the deal is with the last two examples, it's because \texttt{mod} and \texttt{rem} can only represent integral division. If all you have to work with is integers, then dividing a smaller number by a larger number results in an answer of 0 with a remainder of whatever the smaller number (the dividend) is. If you want to divide a smaller number by a larger number and return a fractional answer, then you need to use \texttt{(/)}, and you won't have a remainder.

Let's say we need to write a function that will determine what day of the week it was or will be a certain number of days before or after this one. For our purposes here, we will assign a number to each day of the week, using 0 to represent Sunday.\footnote{ Sure, you may naturally think of the days of week as being numbered 1-7. But programmers like to index things from zero. } Then if today is Monday, and we want to know what day of the week it will be 23 days from now, we could do this:

\begin{verbatim}
Prelude> mod (1 + 23) 7
3
\end{verbatim}

The 1 represents Monday, the current day, while 23 is the number of days we're trying to add. Using \texttt{mod} to wrap it around the 7 means it will return a number that corresponds to a day of the week in our numbering. 

And 5 days from Saturday will be Thursday:

\begin{verbatim}
Prelude> mod (6 + 5) 7
4
\end{verbatim}

We can use \texttt{rem} to do the same thing with apparently equivalent accuracy:

\begin{verbatim}
Prelude> rem (1 + 23) 7
3
\end{verbatim}

However, if we want to \emph{subtract} and find out what day of the week it was some number of days ago, then we'll see a difference. Let's try asking, if today is Wednesday (3), what day it was 12 days ago:

\begin{verbatim}
Prelude> mod (3 - 12) 7
5
Prelude> rem (3 - 12) 7
-2
\end{verbatim}

The version with \texttt{mod} gives us a correct answer, while the \texttt{rem} version does not. 
%% i have no fucking idea at this point if i could have just used rem for the caesar cipher etc. 

One key difference here is that, in Haskell (not in all languages), if one or both arguments are negative, the results of \texttt{mod} will have the same sign as the divisor, while the result of \texttt{rem} will have the same sign as the dividend:

\begin{verbatim}
Prelude> (-5) `mod` 2
1
Prelude> 5 `mod` (-2)
-1
Prelude> (-5) `mod` (-2)
-1

-- but 

Prelude> (-5) `rem` 2
-1
Prelude> 5 `rem` (-2)
1
Prelude> (-5) `rem` (-2)
-1
\end{verbatim}

Figuring out when you need \texttt{mod} takes some experience, and it may not be obvious right now. But you will need it later in the book.

\subsection{Negative numbers}

Due to the interaction of parentheses, currying, and infix syntax, negative numbers get special treatment in Haskell.

If you want a value that is a negative number by itself, this will work just fine:

\begin{verbatim}
Prelude> -1000
-1000
\end{verbatim}

However, this will not work in some cases:

\begin{verbatim}
Prelude> 1000 + -9
<interactive>:3:1:
    Precedence parsing error
        cannot mix ‘+’ [infixl 6] and
        prefix `-` [infixl 6]
           in the same infix expression
\end{verbatim}

Fortunately, we were told about our mistake before any of our code was executed. Note how the error message tells you the problem has to do with precedence. Addition and subtraction have the same precedence (6), and GHCi thinks we are trying to add and subtract, not add a negative number, so it doesn't know how to resolve the precedence and evaluate the expression. We need to make a small change before we can add a positive and a negative number together:

\begin{verbatim}
Prelude> 1000 + (-9)
991
\end{verbatim}

The negation of numbers in Haskell by the use of a unary \texttt{-} is a form of \emph{syntactic sugar}. Syntax is the grammar and structure of the text we use to express programs, and syntactic sugar is a means for us to make that text easier to read and write. Syntactic sugar can make the typing or reading of code nicer but changes nothing about the semantics, or meaning, of programs and doesn't change how we solve problems in code. Typically when code with syntactic sugar is processed by our REPL or compiler, a simple transformation from the shorter (``sweeter'') form to a more verbose, truer representation is performed after the code has been parsed.

In the specific case of \texttt{-}, the syntactic sugar means the operator now has two possible interpretations. The two possible interpretations of the syntactic \texttt{-} are that \texttt{-} is being used as an alias for \texttt{negate} or that it is the subtraction function. The following are semantically identical (that is, they have the same meaning, despite different syntax) because the \texttt{-} is translated into \texttt{negate}:

\begin{verbatim}
Prelude> 2000 + (-1234)
766

Prelude> 2000 + (negate 1234)
766
\end{verbatim}

Whereas this is \texttt{-} being used for subtraction:

\begin{verbatim}
Prelude> 2000 - 1234
766
\end{verbatim}

Fortunately, syntactic overloading like this isn't common in Haskell. 


\section{Parenthesization}

Here we've listed the information that GHCi gives us for various infix operators. We have left the type signatures in this time, although it is not directly relevant at this time. This will give you a chance to look at the types if you're curious and also provide a more accurate picture of the \texttt{:info} command.
\index{GHCi ! :info}

\begin{verbatim}
Prelude> :info (^)
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

Prelude> :info (*)
class Num a where
  (*) :: a -> a -> a
infixl 7 *

Prelude> :info (+)
class Num a where
  (+) :: a -> a -> a
infixl 6 +

Prelude> :info (-)
class Num a where
  (-) :: a -> a -> a
infixl 6 -

Prelude> :info ($)
($) :: (a -> b) -> a -> b
infixr 0 $
\end{verbatim}

We should take a moment to explain and demonstrate the \texttt{(\$)} operator as you will run into it fairly frequently in Haskell code. The good news is it does almost nothing. The bad news is this fact sometimes trips people up.
\index{\$}

First, here's the definition of \texttt{(\$)}:

\begin{code}
f $ a = f a
\end{code}

Immediately this seems a bit pointless until we remember that it's defined as an infix operator with the lowest possible precedence. The \texttt{(\$)} operator is a convenience for when you want to express something with fewer pairs of parentheses:
\index{infix}
\index{parentheses}

\begin{verbatim}
Prelude> (2^) (2 + 2)
16
-- can replace those parentheses
Prelude> (2^) $ 2 + 2
16
-- without either parentheses or $
Prelude> (2^) 2 + 2
6
\end{verbatim}

The \texttt{(\$)} will allow everything to the right of it to be evaluated first and can be used to delay function application. You'll see what we mean about delaying function application in particular when we get to Chapter 7 and use it with function composition.

Also note that you can stack up multiple uses of \texttt{(\$)} in the same expression. For example, this works:

\begin{verbatim}
Prelude> (2^) $ (+2) $ 3*2
256
\end{verbatim}

But this does not:

\begin{verbatim}
Prelude> (2^) $ 2 + 2 $ (*30)
-- A rather long and ugly type error about trying to
-- use numbers as if they were functions follows.
\end{verbatim}

We can see for ourselves why this code doesn't make sense if we examine the reduction steps.
\index{reduction}

\begin{code}
-- Remember ($)'s definition
f $ a = f a

(2^) $ 2 + 2 $ (*30)
-- Given the right-associativity (infixr) of $
-- we must begin at the right-most position.
2 + 2 $ (*30)
-- reduce ($)
(2 + 2) (*30)
-- then we must evaluate (2 + 2) before we can apply it
4 (*30)
-- This doesn't make sense! We can't apply 4
-- as if it was a function to the argument (*30)!
\end{code}

Now let's flip that expression around a bit so it works and then walk through a reduction:

\begin{code}
(2^) $ (*30) $ 2 + 2
-- must evaluate right-side first
(2^) $ (*30) $ 2 + 2
-- application of the function (*30) to the
-- expression (2 + 2) forces evaluation
(2^) $ (*30) 4
-- then we reduce (*30) 4
(2^) $ 120
-- reduce ($) again.
(2^) 120
-- reduce (2^)
1329227995784915872903807060280344576
\end{code}

Some Haskellers find parentheses more readable than the dollar sign, but it's too common in idiomatic Haskell code for you to not at least be familiar with it.

\index{parentheses}
\index{GHCi}

\subsection{Parenthesizing infix operators}

There are times when you want to refer to an infix function without applying any arguments, and there are also times when you want to use them as prefix operators instead of infix. In both cases you must wrap the operator in parentheses. We will see more examples of the former case later in the book. For now, let's look at how we use infix operators as prefixes.
\index{infix ! parenthesization for prefix use}

If your infix function is \texttt{>>} then you must write \texttt{(>>)} to refer to it as a value. \texttt{(+)} is the addition infix function without any arguments applied yet and \texttt{(+1)} is the same addition function but with one argument applied, making it return the next argument it's applied to plus one:

\begin{verbatim}
Prelude> 1 + 2
3
Prelude> (+) 1 2
3
Prelude> (+1) 2
3
\end{verbatim}

The last case is known as \emph{sectioning} and allows you to pass around partially applied functions. With commutative functions, such as addition, it makes no difference if you use \texttt{(+1)} or \texttt{(1+)} because the order of the arguments won't change the result. 
\index{sectioning}

If you use sectioning with a function that is not commutative, the order matters:

\begin{verbatim}
Prelude> (1/) 2
0.5
Prelude> (/1) 2
2.0
\end{verbatim}

Subtraction, \texttt{(-)}, is a special case. These will work:

\begin{verbatim}
Prelude> 2 - 1
1
Prelude> (-) 2 1
1
\end{verbatim}

The following, however, won't work:

\begin{verbatim}
Prelude> (-2) 1
\end{verbatim}

Enclosing a value inside the parentheses with the \texttt{-} indicates to GHCi that it's the argument of a function. Because the \texttt{-} function represents negation, not subtraction, when it's applied to a single argument, GHCi does not know what to do with that, and so it returns an error message. Here, \texttt{-} is a case of syntactic overloading disambiguated by how it is used.
\index{parentheses}
\index{negation}

You can use sectioning for subtraction, but it must be the first argument:

\begin{verbatim}
Prelude> let x = 5
Prelude> let y = (1 -)
Prelude> y x
-4
\end{verbatim}

Or you instead of (- x), you can write (subtract x):

\begin{verbatim}
Prelude> (subtract 2) 3
1
\end{verbatim}

It may not be immediately obvious why you would ever want to do this, but you will see this syntax used throughout the book, for example, once we start wanting to apply functions to each value inside a list or other data structure. We will discuss partial application of functions in more detail in a later chapter as well.


\section{Let and where}

You will often see \texttt{let} and \texttt{where} used to introduce components of expressions, and they seem similar. It takes some practice to get used to the appropriate times to use each, but they are fundamentally different.

The contrast here is that \texttt{let} introduces an \emph{expression}, so it can be used wherever you can have an expression, but \texttt{where} introduces a \emph{declaration} and is bound to a surrounding syntactic construct.
%% CHRIS read 

We'll start with an example of \texttt{where}:

\begin{code}
-- FunctionWithWhere.hs
module FunctionWithWhere where

printInc n = print plusTwo
  where plusTwo = n + 2
\end{code}

And if we use this in the REPL:

\begin{verbatim}
Prelude> :l FunctionWithWhere.hs
[1 of 1] Compiling FunctionWithWhere ...
Ok, modules loaded: FunctionWithWhere.
Prelude> printInc 1
3
Prelude>
\end{verbatim}

Now we have the same function, but using \texttt{let} in the place of \texttt{where}:
\index{let}
\index{where}

\begin{code}
-- FunctionWithLet.hs
module FunctionWithLet where

printInc2 n = let plusTwo = n + 2
              in print plusTwo
\end{code}

When you see \texttt{let} followed by \texttt{in}, you're looking at a \emph{let expression}. Here's that function in the REPL:
\index{let}
\index{in}
\index{let ! expression}

\begin{verbatim}
Prelude> :load FunctionWithLet.hs
[1 of 1] Compiling FunctionWithLet ...
Ok, modules loaded: FunctionWithLet.
Prelude> printInc2 3
5
\end{verbatim}

If you loaded \texttt{FunctionWithLet} in the same REPL session as \texttt{FunctionWithWhere}, then it will have unloaded the first one before loading the new one:
\index{print}
\index{session}

\begin{verbatim}
Prelude> :load FunctionWithWhere.hs
[1 of 1] Compiling FunctionWithWhere ...
Ok, modules loaded: FunctionWithWhere.
Prelude> print
print     printInc
Prelude> printInc 1
3
Prelude> :load FunctionWithLet.hs
[1 of 1] Compiling FunctionWithLet ...
Ok, modules loaded: FunctionWithLet.
Prelude> printInc2 10
12
Prelude> printInc 10

<interactive>:6:1:
    Not in scope: ‘printInc’
    Perhaps you meant ‘printInc2’ (line 4)
\end{verbatim}

\texttt{printInc} isn't in scope anymore because GHCi unloaded everything you'd defined or loaded after you used \texttt{:load} to load the \texttt{FunctionWithLet.hs} source file. Scope is the area of source code where a binding of a variable applies.
\index{scope}

That is one limitation of the \texttt{:load} command in GHCi. As we build larger projects that require having multiple modules in scope, we will use a project manager called Stack rather than GHCi itself.
%% CHRIS does Stack actually fix that? 

\subsection{Exercises: A Head Code}

Now for some exercises. First, determine in your head what the following expressions will return, then validate in the REPL:

\begin{enumerate}

\item
\begin{code}
let x = 5 in x
\end{code}

\item
\begin{code}
let x = 5 in x * x
\end{code}

\item
\begin{code}
let x = 5; y = 6 in x * y
\end{code}

\item
\begin{code}
let x = 3; y = 1000 in x + 3
\end{code}

\end{enumerate}

Above, you entered some \texttt{let} expressions into your REPL to evaluate them. Now, we're going to open a file and rewrite some \texttt{let} expressions using \texttt{where} declarations. You will have to give the value you're binding a name, although the name can be just a letter if you like. For example,

\begin{code}
-- this should work in GHCi
let x = 5; y = 6 in x * y
\end{code}

could be rewritten as

\begin{code}
-- put this in a file
mult1      = x * y
   where x = 5
         y = 6
\end{code}

Making the equals signs line up is a stylistic choice. As long as things are nested in that way, the equals signs do not have to line up. But notice we use a name that we will use to refer to this value in the REPL:

\begin{verbatim}
*Main> :l practice.hs
[1 of 1] Compiling Main
Ok, modules loaded: Main.
*Main> mult1
30
\end{verbatim}

Rewrite with \texttt{where} clauses:

\begin{enumerate}
\item
\begin{code}
let x = 3; y = 1000 in x * 3 + y
\end{code}

\item
\begin{code}
let y = 10; x = 10 * 5 + y in x * 5
\end{code}

\item
\begin{code}
let x = 7; y = negate x; z = y * 10 in z / x + y
\end{code}
\end{enumerate}

Note: the filename you choose is unimportant except for the .hs extension.

\subsection{The lambdas beneath let expressions}

It turns out that there's a fairly straightforward way to express lambdas in Haskell with the provided anonymous function syntax. Recall the identity function that we saw in the lambda calculus chapter:

\begin{verbatim}
λ x . x
\end{verbatim}

Anonymous function syntax in Haskell uses a backslash to represent a lambda. It looks similar to the way it looks in the lambda calculus, and we can use it by wrapping it in parentheses and applying it to values:

\begin{verbatim}
Prelude> (\x -> x) 0
0
Prelude> (\x -> x) 1
1
Prelude> (\x -> x) "blah"
"blah"
\end{verbatim}

The arrow corresponds to the dot that separates a head from a body in lambda expressions.

We can also define the same function in the REPL using \texttt{let}:

\begin{verbatim}
Prelude> let id = \x -> x
Prelude> id 0
0
Prelude> id 1
1
\end{verbatim}

Or we can define it this way:

\begin{verbatim}
Prelude> let id x = x
Prelude> id 0
0
Prelude> id 1
1
\end{verbatim}

Let us translate a few \texttt{let} expressions into their lambda forms!

\begin{code}
let a = b in c

-- equivalent to

(\a -> c) b

-- or a little less abstractly

let x = 10 in x + 9001

(\x -> x + 9001) 10
\end{code}

\subsection{Desugaring let to lambda}
%% CHRIS i'm not sure at this point if this all flows quite properly, but i will revisit that once i have the proof and reorder (not reword unless absolutely necessary) if necessary -- so, basically what i'm saying is if it seems out of order to you at present, try not to sweat it and i'll fix it later.
%% russ abbott seems to think we just dropped the printInc2 here with no explanation and thinks we should write out the reduction, or something. atm, i am inclined to disagree. will revisit after proof. then again, russ abbott is kind of a dick.

We can transform the previous code in the following manner:

\begin{code}
printInc2 n = let plusTwo = n + 2
              in print plusTwo

-- turns into

printInc2' n =
  (\plusTwo -> print plusTwo) (n + 2)
\end{code}

The lambda (backslash) indicates the lambda head that binds the variable. We gave the variable a full name, \texttt{plusTwo}, instead of a single letter. The argument $n + 2$ will be substituted for the variable in the body of the function.

This doesn't work for every possible \texttt{let} expression as we don't have a good way to translate \texttt{let} expressions that use free variables recursively\footnote{Technically let and lambda are different primitives in GHC Haskell's underlying Core language. The point is that Haskell is a pure lambda calculus and, at least theoretically, everything can be desugared into nested lambda expressions.} into the lambda calculus. However, we want you to have a sense of how most things in Haskell can be translated into lambdas. It's all right if you don't understand right now why you'd care about this; we'll revisit this throughout the book.
%% CHRIS changed wording of footnote, ok?

We can do a similar translation with \texttt{where}, although there are some differences:

\begin{code}
c where a = b

-- equivalent to

(\a -> c) b

-- Something more concrete again

x + 9001 where x = 10

(\x -> x + 9001) 10
\end{code}

To use the \texttt{where} version in the REPL, you can do this:

\begin{verbatim}
λ> let f = x + 9001 where x = 10
λ> f
9011
\end{verbatim}

This highlights the difference between \texttt{let} and \texttt{where}. \texttt{let} expressions can introduce a new scope and can be nested; however, \texttt{where} clauses aren't expressions, so they only work within a single scope and can only see what's introduced in the arguments to the function it's inside. Using \texttt{where} is therefore more restrictive, but if that's all you need, you should use \texttt{where} because it shrinks the scope and, thus, the possibilities. 
%% CHRIS is the wording ok? 

There is much more we could say here about relevant differences, but we'll use them both throughout the book and save expanding on this explanation until much later.

We won't break down every single Haskell construct into the underlying lambdas, but try to keep this model in mind as you proceed.


\section{Chapter Exercises}

The goal for all the following exercises is just to get you playing with code and forming hypotheses about what it should do. Read the code carefully, using what we've learned so far. Generate a hypothesis about what you think the code will do. Play with it in the REPL and find out where you were right or wrong.
\index{REPL}

\subsection{Parenthesization}

Given what we know about the precedence of \texttt{(*)}, \texttt{(+)}, and \texttt{(\textasciicircum)}, how can we parenthesize the following expressions more explicitly without changing their results? Put together an answer you think is correct, then test in the GHCi REPL.

Example:

\begin{code}
-- We want to make this more explicit
2 + 2 * 3 - 3

-- this will produce the same result
2 + (2 * 3) - 3
\end{code}

Attempt the above on the following expressions.

\begin{enumerate}

\item
\begin{code}
2 + 2 * 3 - 1
\end{code}

\item
\begin{code}
(^) 10 $ 1 + 1
\end{code}

\item
\begin{code}
2 ^ 2 * 4 ^ 5 + 1
\end{code}

\end{enumerate}


\subsection{Equivalent expressions}

Which of the following pairs of expressions will return the same result when evaluated? Try to reason them out in your head by reading the code and then enter them into the REPL to check your work:

\begin{enumerate}

\item
\begin{code}
1 + 1

2
\end{code}

\item
\begin{code}
10 ^ 2

10 + 9 * 10
\end{code}

\item
\begin{code}
400 - 37

(-) 37 400
\end{code}

\item
\begin{code}
100 `div` 3

100 / 3
\end{code}

\item
\begin{code}
2 * 5 + 18

2 * (5 + 18)
\end{code}

\end{enumerate}


\subsection{More fun with functions}

Here is a bit of code as it might be entered into a source file. Remember that when you write code in a source file, the order is unimportant, but when writing code directly into the REPL the order does matter. Given that, look at this code and rewrite it such that it could be evaluated in the REPL (remember: you'll need \texttt{let} when entering it directly into the REPL). Be sure to enter your code into the REPL to make sure it evaluates correctly.

\begin{code}
z = 7

x = y ^ 2

waxOn = x * 5

y = z + 8
\end{code}

\begin{enumerate}

\item Now you have a value called \texttt{waxOn} in your REPL. What do you think will happen if you enter:

\begin{code}
10 + waxOn
-- or
(+10) waxOn
-- or
(-) 15 waxOn
-- or
(-) waxOn 15
\end{code}

\item Earlier we looked at a function called \texttt{triple}. While your REPL has \texttt{waxOn} in session, re-enter the \texttt{triple} function at the prompt:

\begin{code}
let triple x = x * 3
\end{code}

\item Now, what will happen if we enter this at our GHCi prompt. Try to reason out what you think will happen first, considering what role \texttt{waxOn} is playing in this function call. Then enter it, see what does happen, and check your understanding:

\begin{code}
triple waxOn
\end{code}

\item Rewrite \texttt{waxOn} as an expression with a \texttt{where} clause in your source file. Load it into your REPL and make sure it still works as expected!

\item Now to the same source file where you have \texttt{waxOn}, add the \texttt{triple} function. Remember: You don't need \texttt{let} and the function name should be at the left margin (that is, not nested as one of the \texttt{waxOn} expressions). Make sure it works by loading it into your REPL and then entering \texttt{triple waxOn} again at the REPL prompt. You should have the same answer as you did above.

\item Now, without changing what you've done so far in that file, add a new function called \texttt{waxOff} that looks like this:

\begin{code}
waxOff x = triple x
\end{code}

\item Load the source file into your REPL and enter \texttt{waxOff waxOn} at the prompt.

You now have a function, \texttt{waxOff} that can be applied to a variety of arguments --- not just \texttt{waxOn} but any (numeric) value you want to put in for $x$. Play with that a bit. What is the result of \texttt{waxOff 10} or \texttt{waxOff (-50)}? Try modifying your \texttt{waxOff} function to do something new --- perhaps you want to first triple the $x$ value and then square it or divide it by 10. Just spend some time getting comfortable with modifying the source file code, reloading it, and checking your modification in the REPL.

\end{enumerate}


\clearpage


\section{Definitions}

\begin{enumerate}

\item The terms \emph{argument} and \emph{parameter} are often used interchangeably. However, it is worthwhile to understand the distinction. A \emph{parameter}, or formal parameter, \emph{represents} a value that will be passed to the function when the function is called. Thus, parameters are usually variables. An \emph{argument} is an input value the function is applied to. A function's parameter is bound to the value of an argument when the function is applied to that argument. For example, in \texttt{f x = x + 2} which takes an argument and returns that value added to 2, $x$ is the one parameter of our function. We run the code by applying $f$ to some argument. If the argument we passed to the parameter $x$ were 2, our result would be 4. However, arguments can themselves be variables or be expressions that include variables, thus the distinction is not always clear. When we use ``parameter'' in this book, it will always be referring to formal parameters, usually in a type signature, but we've taken the liberty of using ``argument'' somewhat more loosely. 

\item An \emph{expression} is a combination of symbols that conforms to syntactic rules and can be evaluated to some result. In Haskell, an expression is a well-structured combination of constants, variables, and functions. While irreducible constants are technically expressions, we usually refer to those as ``values'', so we usually mean ``reducible expression'' when we use the term \emph{expression}.

\item A \emph{redex} is a reducible expression.

\item A \emph{value} is an expression that cannot be reduced or evaluated any further. \texttt{2 * 2} is an expression, but not a value, whereas what it evaluates to, 4, is a value.

\item A \emph{function} is a mathematical object whose capabilities are limited to being applied to an argument and returning a result. Functions can be described as a list of ordered pairs of their inputs and the resulting outputs, like a mapping. Given the function \texttt{f x = x + 2} applied to the argument 2, we would have the ordered pair \texttt{(2, 4)} of its input and output.

\item \emph{Infix notation} is the style used in arithmetic and logic. Infix means that the operator is placed between the operands or \emph{arguments}. An example would be the plus sign in an expression like \texttt{2 + 2}.

\item \emph{Operators} are functions that are infix by default. In Haskell, operators must use symbols and not alphanumeric characters.

\item \emph{Syntactic sugar} is syntax within a programming language designed to make expressions easier to write or read.
\end{enumerate}


\section{Follow-up resources}

\begin{enumerate}
\item Haskell wiki article on Let vs. Where \\ \url{https://wiki.haskell.org/Let_vs._Where}
\item How to desugar Haskell code; Gabriel Gonzalez \\ \url{http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html} \\
\end{enumerate}
